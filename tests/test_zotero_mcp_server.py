"""Tests for the Zotero MCP Server implementation"""

import logging
import json

import pytest

from zotero_mcp_server.zotero_mcp_server import pyzotero_search_library,get_parent_collections
from zotero_mcp_server.pyzotero_wrapper import note_parser


logging.basicConfig(
    level=logging.INFO,
    datefmt="%Y-%m-%d %H:%M:%S",
    format="%(asctime)s - %(levelname)s - %(message)s"
)
test_logger = logging.getLogger(__name__)


class TestPyzoteroSearch:
    """Collection of tests regarding my pyzotero search wrapper."""

    # Simulates inputs generated by an llm
    @pytest.mark.parametrize("limit, query",[
        (0, ""), # For wrongly set limit by llm
        (1, "Rindfleischetikettierungsüberwachungsaufgabenübertragungsgesetz"), # For no result case
        (10, "llm"),
        (100, "llm"),
        (10000, "git"),
        (100, ""),
        (100000, "")
    ])
    def test_pyzotero_search_library(self, limit: int, query: str) -> None:
        """Test pyzotero search library function"""
        test_logger.info("Running test with limit: %d and query: %s", limit, query)
        assert isinstance(limit, int)
        assert isinstance(query, str)

        found_items = pyzotero_search_library(limit=limit, query=query)

        assert isinstance(found_items, list)
        if found_items:
            for found_item in found_items:
                assert isinstance(found_item, dict)

    # def test_pyzotero_search_parser(self) -> None:
    #     raise NotImplementedError

    # Similates the collection key of a found item
    @pytest.mark.parametrize("collection_key", ["8NXHKXXC"])
    def test_get_parent_collections(self, collection_key: str) -> None:
        """Test recursively retrieving the names of a collection and its parent collections"""

        test_logger.info("Running test with collection_key: %s", collection_key)

        item_collection_names = get_parent_collections(collection_key)[0]

        test_item_collection_names = ['Collection depth=0: Machine Learning',
                                        'Collection depth=1: Interesting Ideas',
                                        'Collection depth=2: MCP (Model Context Protocol)']
        assert item_collection_names == test_item_collection_names

@pytest.fixture(scope="function", name="static_pyzotero_items_fixture")
def static_pyzotero_items():
    """Fixture to load static pyzotero responses from a JSON file."""
    
    return _read_json("./tests/test_pyzotero_items.json")

@pytest.fixture(scope="function", name="notes_items_fixture")
def notes_items(static_pyzotero_items_fixture):
    """Fixture to extract the note items from the static pyzotero items"""
    return static_pyzotero_items_fixture["notes"]

@pytest.fixture(scope="function", name="notes_html_fixture")
def notes_html(notes_items_fixture):
    """Fixture to extract the notes html from note items."""
    return [note_item["data"]["note"] for note_item in notes_items_fixture]

@pytest.fixture(scope="function", name="notes_titles_fixture")
def notes_titles(notes_items_fixture):
    """Fixture to extract the notes html from note items."""
    return [note_item["data"]["test_note_title"] for note_item in notes_items_fixture]

class TestParsers:
    """Test for different pyzotero item type parsers"""

    def test_note_title_parser(self, notes_html_fixture, notes_titles_fixture):
        """Test note title parser extracts correct note"""

        parsed_notes_titles = [note_parser(note_html) for note_html in notes_html_fixture]
        assert parsed_notes_titles == notes_titles_fixture


def _read_json(filename: str) -> dict:
    """Reads data from a JSON file and returns it as a Python dictionary.

    Args:cl
        filename (str): The name of the JSON file to read.

    Returns:
        dict: A Python dictionary representing the data from the JSON file.
              Returns an empty dictionary if the file is not found or an error occurs.
    """
    try:
        with open(filename, "r", encoding="utf-8") as json_file:
            data = json.load(json_file)
        return data
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")
        return {}
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from '{filename}'. \
              The file might be corrupted or not valid JSON.")
        return {}
    except IOError as e:
        print(f"Error reading file '{filename}': {e}")
        return {}

